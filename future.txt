
 * after finding %:, but its neither rule definition nor file include, invoke ::m5_main_syntax.
 
 * say you have the quote {''`}. When you then quote this quote like this: ' {''`} ` ... you see the problem.
   -> always use {'`}.

 * make m5 input one large "source invocation string". such that quotes and invocations may also exist at file scope.
   for that, make it possible for rules to be defined in an invocation string.
   this also neatly introduces local rules and scopes.

 * Implement folding of arbitrary text through private unicode symbols.
 * compile rules and add as dynamic modules on-the-fly
 * isolate the meaning and syntax of what is represented by '%:': the entry point for m5 syntax.
   make it flexible.
   make simple tool which safely changes some $file o $file.m5, escaping occurences of '%:' or whatever
 * %: https://example.com/include.m5
 * m5 can also function as an on-the-fly preprocessor for interpreted languages.

 * internally, i should seriously start passing around syntax trees instead of raw strings... search for @9263738

 * i might introduce
      %: meta! {
          syntax email_char = {::aZ} or {::09} or {.}.
          syntax email = {::email_char}+@{::email_char}+.
      }
   , but that clashes with
      %: (syntax) {::some_rule}
   , however, i thought i should replace (syntax), because all this flag does is make the application of some_rule
   also effective for results of other rule applications. but this doesnt make the rule more or less of a syntax.

 * needed: counted quotes. example:
   %: add_variant(:content:rest) -> {
      %: rule {some text and then {«'»:content«`»}}
   }
   :content is intended to be inserted as constant text, without rule invocations.
   however, the caller could just pass ::add_variant(«`»}'::invocation`{«'») e.g. it could just pass anti-quoted »::rule«
   thats why we need counted rules. :content corresponds to a String in Rust. taking length is O(1). 
   also, advancing a &str by a number is O(n) but still efficient enough.
   so instead of 
      {«'»:content«`»} 
   it should be possible to do sth like
      ->STRLEN(content):content
   which is interpreted like a quote but with a fixed specified length.
   just gotta work out a non-sucky way to do it though....

 * library shouldnt include from /usr/local/lib/ ...

 * make backtrace userdefined... 
   * add syntax: %: (backtrace) <rule definition>
   * rule definition name must be empty
   * applies rule definition once
   * result is added to the backtrace, which will be printed on an uncaught error.
   * add syntax %: (backtrace) (pop) <warning if followed by rule definition> 
             or %: (pop) (backtrace) <warning if followed by rule definition> 

  * rusty c:
     * c, but variables are const by default
     * smart pointer
     * tagged unions
     * tuples
     * anonymous structs


 * feature to make one m5 procession unit be able to output multiple files
    - introduce new syntax:
        %: multiple_file_output_feature {%: send to :name:until_space} -> {::set_current_file_output(:name)}
    - every procession unit must therefore begin with this syntax
    - a input file to m5 is called "included file" if it does not begin with this syntax